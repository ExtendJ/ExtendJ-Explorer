aspect ValidateExpressions{
    syn boolean Expr.isDoubleDecl() = false;
    syn boolean Expr.isBinExpression() = false;
    eq BinExpr.isBinExpression() = true;

    eq BinExpr.isDoubleDecl() = getLeft().isLangDecl() && getRight().isLangDecl();

    syn LangDecl Expr.getDecl() = null;
    eq ChildOf.getDecl() = getLangDecl();
    eq ParentOf.getDecl() = getLangDecl();

    eq BinExpr.getDecl(){
        if(getLeft().isLangDecl())
            return (LangDecl) getLeft();
        return (LangDecl) getRight();
    }

    syn Value BinExpr.getValue(){
        if(!getLeft().isLangDecl())
            return  getLeft();
        return getRight();
    }

    syn String Value.getStr() = null;
    syn int Value.getInt() = 0;
    syn boolean Value.getBool() = false;
    syn String Value.getColor() = "#000000";

    eq OnOff.getBool() = getONOFF().equals("on");
    eq Bool.getBool() = Boolean.parseBoolean(getBOOL());
    eq Num.getInt() = Integer.parseInt(getNUMERAL());
    eq Str.getStr() = getString().substring(1, getString().length()-1);

    // ============================
    // See if an variable, var, is correct according to the filter, oohhh so much copy paste.
    // ============================

    syn boolean Expr.validateExpr(Object attr) = false;
    syn boolean Expr.validateExpr(drast.model.Node node) = false;

    // child- and parent of
    syn boolean ChildOf.isNot() = getNot().getBool();
    syn boolean ParentOf.isNot() = getNot().getBool();

    syn boolean ChildOf.isChildOf(drast.model.Node node){
        drast.model.Node parent = node.parent;
        if(parent == null)
            return false;
        boolean ret = parent.getSimpleNameClass().equals(getLangDecl().getID());
        return isNot() ? !ret : ret;
    }

    syn boolean ParentOf.isParentOf(drast.model.Node node){
        boolean ret;
        for(drast.model.Node child : node.children){
            ret = child.getSimpleNameClass().equals(getLangDecl().getID());
            if(ret)
                return isNot() ? !ret : ret;
        }
        return isNot();
    }
    eq ChildOf.validateExpr(drast.model.Node node) = isChildOf(node);
    eq ParentOf.validateExpr(drast.model.Node node) = isParentOf(node);


    eq BinExpr.validateExpr(Object attr){
        try{
            if(getValue().isBool())
                return validateExpression((boolean) attr);
            if(getValue().isInt() || getValue().isIntArray())
                return validateExpression((int) attr);
            if(getValue().isString() || getValue().isStrArray())
                return validateExpression((String) attr);
        }catch (ClassCastException e) {
             e.printStackTrace();
        }
        return false;
    }

    syn boolean Expr.validateExpression(int attr) = false;
    syn boolean Expr.validateExpression(boolean attr) = false;
    syn boolean Expr.validateExpression(String attr) = false;

    //IN and NOTIN for string, Integer and boolean

    eq In.validateExpression(String attr) = getValue().isPartOf(getValue(), attr, true);
    eq In.validateExpression(int attr) = getValue().isPartOf(getValue(), attr, true);

    eq NotIn.validateExpression(String attr) = getValue().isPartOf(getValue(), attr, false);
    eq NotIn.validateExpression(int attr) = getValue().isPartOf(getValue(), attr, false);

     syn boolean Value.isPartOf(Value val, int attr, boolean returnValue){
        if(val.isIntArray()){
            for(Num in : ((NumArray)val).getNumList()){
                if(in.getInt() == attr)
                    return returnValue;
            }
            return !returnValue;
        }
        return false;
     }

     syn boolean Value.isPartOf(Value val, String attr, boolean returnValue){
         if(val.isStrArray()){
             for(Str str : ((StrArray)val).getStrList()){
                 if(str.getStr().equals(attr))
                     return returnValue;
             }
             return !returnValue;
         }
         return false;
     }

    // String
    eq EQ.validateExpression(String attr) = getValue().getStr().equals(attr);
    eq NEQ.validateExpression(String attr) = !(getValue().getStr().equals(attr));

    //Boolean
    eq EQ.validateExpression(boolean attr) = (getValue().getBool() && attr) || (!getValue().getBool() && !attr);
    eq NEQ.validateExpression(boolean attr) = (getValue().getBool() && !attr) || (!getValue().getBool() && attr);

    // Integer
    eq EQ.validateExpression(int attr) = getValue().getInt() == attr;
    eq NEQ.validateExpression(int attr) = !(getValue().getInt() == attr);

    eq LEQ.validateExpression(int attr) = getValue().getInt() >= attr;
    eq GEQ.validateExpression(int attr) = getValue().getInt() <= attr;
    eq LT.validateExpression(int attr) = getValue().getInt() > attr;
    eq GT.validateExpression(int attr) = getValue().getInt() < attr;

    // ---------------- two variables

    syn boolean BinExpr.validateExpr(Object attr, Object attr2, Class type, String decl){
        try{
            if(type.equals(boolean.class))
                return validateExpression((boolean) attr, (boolean) attr2);
            if(type.equals(int.class)){
                return validateExpression((int) attr, (int) attr2);
            }if(type.equals(String.class))
                return validateExpression((String) attr, (String) attr2);
        }catch (ClassCastException e) {
             e.printStackTrace();
        }
        return false;
    }

    syn boolean BinExpr.validateExpression(int attr, int attr2) = false;
    syn boolean BinExpr.validateExpression(boolean attr, boolean attr2) = false;
    syn boolean BinExpr.validateExpression(String attr, String attr2) = false;

    // String
    eq EQ.validateExpression(String attr, String attr2) = attr.equals(attr2);
    eq NEQ.validateExpression(String attr, String attr2) = !attr.equals(attr2);

    // Boolean
    eq EQ.validateExpression(boolean attr, boolean attr2) = (attr && attr2) || (!attr && !attr2);
    eq NEQ.validateExpression(boolean attr, boolean attr2) = (attr && !attr2) || (!attr && attr2);

    // Integer
    eq EQ.validateExpression(int  attr, int attr2) = attr == attr2;
    eq NEQ.validateExpression(int attr, int attr2) = attr != attr2;
    eq LEQ.validateExpression(int attr, int attr2) = attr <= attr2;
    eq GEQ.validateExpression(int attr, int attr2) = attr >= attr2;
    eq LT.validateExpression(int attr, int attr2) = attr < attr2;
    eq GT.validateExpression(int attr, int attr2) = attr > attr2;
}