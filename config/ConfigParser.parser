%header {: // this code is inlined before the generated parser
 package AST;
:};

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		String error = "";
		error += Symbol.getLine(token.getStart());
		error += ',';
		error += Symbol.getColumn(token.getStart());
		error += '-';
		error += Symbol.getLine(token.getEnd());
		error += ',';
		error += Symbol.getColumn(token.getEnd());
		error += ": Syntax Error: unexpected token ";
		if (token.value != null)
		{
			error += '"';
			error += token.value;
			error += '"';
		}
		else
		{
			error += '#';
			error += token.getId();
		}
		throw new SyntaxError(error);
	}
:};

%goal debuggerconfig

DebuggerConfig debuggerconfig = configs.a include.b {: return new DebuggerConfig(new Opt(a), b); :}
		| include.a {: return new DebuggerConfig(new Opt(), a); :} ;

BindingList binding_list =
	/*EmptyList*/ {: return new BindingList(new List()); :}
	| binding_tmp.a SEMI {: return new BindingList(a); :};


List binding_tmp =
 	binding.d {: return new List().add(d); :}
 	| binding_tmp.c SEMI binding.d {: return c.add(d); :} ;

Binding binding = iddecl.a ASSIGNMENT value.b {: return new Binding(a,b); :};

List include =
	INCLUDE LBRACKET RBRACKET {: return new List(); :}
	| INCLUDE LBRACKET node_list.a RBRACKET {: return a; :} ;

List node_list =
	node.e {: return new List().add(e); :}
	| node_list.f node.g {: return f.add(g); :} ;

NodeConfig node =
	node_name.a SEMI {: return new NodeConfig(a, new Opt(), new Opt()); :}
	| node_name.a LBRACKET RBRACKET {: return new NodeConfig(a, new Opt(), new Opt()); :}
	| node_name.a LBRACKET filter.c RBRACKET {: return new NodeConfig(a, new Opt(c), new Opt()); :}
	| node_name.a LBRACKET configList.c RBRACKET {: return new NodeConfig(a, new Opt(), new Opt(c)); :}
	| node_name.a LBRACKET filter.c configList.d RBRACKET {: return new NodeConfig(a, new Opt(c), new Opt(d)); :};

NodeName node_name =
	iddecl.a  {: return new NodeName(a, new Opt()); :}
	| iddecl.a COL iddecl.b {: return new NodeName(a, new Opt(b)); :};

ConfigList configList = configList_list.a {: return new ConfigList(a); :}

List configList_list  =
	configs.a {: return new List().add(a); :}
	| configList_list.a configs.b {: return a.add(b); :};

Configs configs =
	iddecl.a LBRACKET binding_list.h RBRACKET {: return new Configs(a, new Opt(h)); :};

Filter filter =
	FILTER LBRACKET filter_list.c RBRACKET {: return new Filter(c); :};

List filter_list =
		/*Empty*/{: return new List(); :}
		| filter_tmp.a SEMI {: return a; :};

List filter_tmp =
	binexpr.h {: return new List().add(h); :}
	| filter_tmp.i SEMI binexpr.j {: return i.add(j); :} ;

BinExpr binexpr =
	 value.a EQ value.b {:return new EQ(a,b); :}
	| value.a NEQ value.b {:return new NEQ(a,b); :}
	| value.a LEQ value.b  {:return new LEQ(a,b); :}
	| value.a GEQ value.b {:return new GEQ(a,b); :}
	| value.a LT value.b {:return new LT(a,b); :}
	| value.a GT value.b {:return new GT(a,b); :} ;

Value value =
	LSQBRACKET empty_list.a RSQBRACKET {: return a; :}
	| num
	| str
	| BOOL.a {: return new Bool(a); :}
	| iddecl
	| color;

Value empty_list =
	/*EmptyList*/ {: return new EmptyArray(); :}
	| str_list.a {: return new StrArray(a); :}
	| num_list.a {: return new NumArray(a); :};

List str_list =
	 str.l {: return new List().add(l); :}
	| str_list.m COMMA str.n {: return m.add(n); :} ;

List num_list =
	 num.o {: return new List().add(o); :}
	| num_list.p COMMA num.q {: return p.add(q); :} ;

Num num =  NUMERAL.a {: return new Num(a); :};
Str str = STRING.a {: return new Str(a); :};
IdDecl iddecl = ID.a {: return new IdDecl(a); :};
Color color = COLOR.a {: return new Color(a); :};
